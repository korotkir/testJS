// Создание объекта с помощью класса Object с методом create()
// Такой подход позволяет настроивать различные параметры объекта.

// Тут есть отличия от привычной нам записи
const person = Object.create(
    {
        // В данном объекте мы можем указывать прототип нового созданного объекта person
        calculateAge() {
            console.log('Age:', new Date().getFullYear() - this.birthYear )
            // person.calculateAge() в консоли дасть результат
        }
    },
    {
    name: {
        value: 'Kirill',
        enumerable: true, // параметр для включения значения в цикл
        writable: true, // параметр для включения перезаписи значения
        configurable: true // разрешает удалять поля из объекта

    },
    birthYear: {
        value: 1998
    },
    age: {
        // Как нам вычислить возраст человека на основе его даты рождения?
        // Для этого воспользуемся методами getter и setter

        // get - мы должны вернуть какое то значение
        // в этих функциях мы можем выполнять любую логику
        get() {
            return new Date().getFullYear() - this.birthYear
        },
        set(value) {
            console.log('Set age', value)
            // Мы можем сами задать возраст, person.age = 100
        },
    }
}
)

console.log(person)

/*
 Эти поля как бы присутствуют в объекте,
 но если мы будем например делать итерацию
 по ключам данного объекта эти ключи не будут входить в цикл
Для того чтобы вернуть дефолтное поведение,
мы можем настраивать поведение ключей, мы можем настраивать
эти поля.
Для того чтобы поле name было видно в цикле for, мы можем использовать параметр enumerable
*/

// person.name = 'Maxim' // данное значение не сработает из за того, что по умолчанию writable = false


// Помимо ключей мы получаем определенные ключи,
// мы получаем значение функции которая находится в прототипе
// чтобы этого не было добавим в цикл проверку
for (let key in person) {
    if (person.hasOwnProperty(key)) {
        console.log('Key', key, person[key])
    }
}